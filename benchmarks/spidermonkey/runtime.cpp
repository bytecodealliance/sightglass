// Largely borrowed barebones SpiderMonkey toplevel wrapper from:
// https://github.com/fastly/js-compute-runtime/blob/main/c-dependencies/js-compute-runtime/js-compute-runtime.cpp

#include <cassert>
#include <cstdlib>
#include <iostream>

#include <wasi/libc-environ.h>

#include "sightglass.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"

#include "jsapi.h"
#include "jsfriendapi.h"

#include "js/CompilationAndEvaluation.h"
#include "js/ContextOptions.h"
#include "js/ForOfIterator.h"
#include "js/Initialization.h"
#include "js/Object.h"
#include "js/SourceText.h"

// Include all JS files - generated by build script
#include "js_files.h"

#pragma clang diagnostic pop

using JS::Value;

using JS::RootedValue;
using JS::RootedObject;
using JS::RootedString;

using JS::HandleValue;
using JS::HandleObject;
using JS::MutableHandleValue;

using JS::PersistentRooted;
using JS::PersistentRootedVector;

/* The class of the global object. */
static JSClass global_class = {
    "global",
    JSCLASS_GLOBAL_FLAGS,
    &JS::DefaultGlobalClassOps
};

JSContext* CONTEXT = nullptr;

JS::PersistentRootedObject GLOBAL;

static JS::PersistentRootedObjectVector* FETCH_HANDLERS;

bool init_js() {
  JS_Init();

  JSContext *cx = JS_NewContext(JS::DefaultHeapMaxBytes);
  if (!cx)
      return false;
  if (!js::UseInternalJobQueues(cx) || !JS::InitSelfHostedCode(cx))
      return false;

  JS::RealmOptions options;
  options.creationOptions()
    .setStreamsEnabled(true);

  RootedObject global(cx, JS_NewGlobalObject(cx, &global_class, nullptr, JS::FireOnNewGlobalHook,
                                             options));
  if (!global)
      return false;

  JSAutoRealm ar(cx, global);
  if (!JS::InitRealmStandardClasses(cx))
    return false;


  CONTEXT = cx;
  GLOBAL.init(cx, global);

  return true;
}

// Helper to compile and execute a JS file
bool compile_and_execute_js(JSContext* cx,
                            const char* src,
                            size_t src_len,
                            const char* filename) {
  JS::SourceText<mozilla::Utf8Unit> srcBuf;
  if (!srcBuf.init(cx, src, src_len, JS::SourceOwnership::Borrowed)) {
    return false;
  }

  JS::CompileOptions opts(cx);
  opts.setForceFullParse();
  opts.setFileAndLine(filename, 1);
  JS::RootedScript script(cx, JS::Compile(cx, opts, srcBuf));
  if (!script) {
    return false;
  }
  
  JS::RootedValue result(cx);
  if (!JS_ExecuteScript(cx, script, &result)) {
    return false;
  }

  return true;
}

bool eval_bench(JSContext* cx,
                JS::HandleObject global,
                const char* input) {
  // Load JS files in order
  // This happens outside bench_{start,end} as it would typically be Wizer'd away
  
  // If marked.min.js.h was included (markdown benchmark), load it first
  #if __has_include("marked.min.js.h")
  if (!compile_and_execute_js(cx, (const char*)marked_min_js, marked_min_js_len, "marked.min.js")) {
    fprintf(stderr, "Failed to load marked.min.js\n");
    return false;
  }
  #endif

  // Load main.js (all benchmarks have this)
  if (!compile_and_execute_js(cx, (const char*)main_js, main_js_len, "main.js")) {
    fprintf(stderr, "Failed to load main.js\n");
    return false;
  }

  // Now call the main function with the input
  JS::RootedValue arg(cx, JS::StringValue(JS_NewStringCopyZ(cx, input)));

  bench_start();
  JS::RootedValue result(cx);
  if (!JS_CallFunctionName(cx, global, "main", JS::HandleValueArray(arg), &result)) {
    return false;
  }
  bench_end();

  // Print result
  JS::RootedString resultStr(cx, result.toString());
  JS::AutoAssertNoGC nogc(cx);
  size_t len = 0;
  const JS::Latin1Char* chars = JS_GetLatin1StringCharsAndLength(cx, nogc, resultStr, &len);
  printf("%.*s", (int) len, chars);

  return true;
}

char* readFile(const char* path) {
  FILE* f = fopen(path, "r");
  assert(f && "should open path okay");

  fseek(f, 0, SEEK_END);
  ssize_t len = ftell(f);
  fseek(f, 0, SEEK_SET);

  char* contents = (char*) malloc(len + 1);
  assert(contents && "should malloc contents okay");

  ssize_t nread = fread(contents, len, 1, f);
  assert(nread == 1 && "should read all bytes");

  fclose(f);
  contents[len] = '\0';
  return contents;
}

// Input filename is set via compile-time define
#ifndef INPUT_FILE
#error "INPUT_FILE must be defined"
#endif

int main(int argc, const char *argv[]) {

  if (!init_js()) {
    exit(1);
  }

  JSContext* cx = CONTEXT;
  RootedObject global(cx, GLOBAL);
  JSAutoRealm ar(cx, global);
  FETCH_HANDLERS = new JS::PersistentRootedObjectVector(cx);

  char* input = readFile(INPUT_FILE);

  if (!eval_bench(cx, global, input)) {
    fprintf(stderr, "Error evaluating JS!\n");
    JS::RootedValue exn(cx);
    if (JS_GetPendingException(cx, &exn)) {
      JS::RootedObject exnObj(cx, &exn.toObject());
      JSErrorReport* report = JS_ErrorFromException(cx, exnObj);
      JS::PrintError(stderr, report, true);
    }
    exit(1);
  }

  printf("All done!\n");
}
